"""Git-Sensei: AI-powered commit message generator."""
import shutil
import sys
import os
import re
import typer
from typing import Optional

from config import ConfigManager
from providers import AIProvider
from secrets import scan_diff, format_warning
from git_utils import get_staged_diff, get_current_branch, extract_issue_id, create_commit, get_git_context

app = typer.Typer(
    help="Git-Sensei: AI-powered commit message generator. Quick start: git add . && sensei commit",
    add_completion=False,
    rich_markup_mode=None,
)
config_mgr = ConfigManager()

CONVENTIONAL_REGEX = r"^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\([a-z0-9_\-\./+]+\))?: .+$"

DEFAULT_PROMPT = """You are a professional git commit message generator.

TASK: Analyze the git diff and generate a complete, professional commit message.

OUTPUT FORMAT (output ONLY the commit message, nothing else):

type(scope): concise summary (max 72 chars)

Brief paragraph explaining WHAT changed and WHY (2-3 sentences).

- Bullet point for specific change 1
- Bullet point for specific change 2
- Bullet point for specific change 3

{issue_footer}

RULES:
- Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore
- Use imperative mood: "add", "fix", "update" (not "added", "fixed")
- First line max 72 characters
- Be specific about what changed and why
- Group related changes in bullet points
- NO markdown formatting, NO preamble like "Here's the commit message:"
- Start DIRECTLY with the type (feat/fix/etc)
- NO signatures like "Generated with..." or "Co-Authored-By"

{context}"""


def build_prompt_with_context(base_prompt: str, git_context: dict) -> str:
    """Build final prompt with git context injected."""
    context_lines = []

    if git_context.get('context_summary'):
        context_lines.append(f"CONTEXT: {git_context['context_summary']}")

    if git_context.get('branch_type'):
        context_lines.append(f"SUGGESTED TYPE: {git_context['branch_type']}")

    context_str = '\n'.join(context_lines) if context_lines else ''

    # Handle issue footer
    issue_id = git_context.get('issue_id')
    if issue_id:
        issue_footer = f"Closes {issue_id}"
    else:
        issue_footer = ""

    return base_prompt.replace('{context}', context_str).replace('{issue_footer}', issue_footer)


def strip_signatures(message: str) -> str:
    """Remove AI-generated signatures and footers from commit message."""
    patterns = [
        r'\n*ðŸ¤–.*Generated with.*$',
        r'\n*Generated with \[?Claude.*$',
        r'\n*Co-Authored-By:.*$',
        r'\n*---\n*.*Generated.*$',
        r'\n*\*Generated by.*$',
    ]
    result = message
    for pattern in patterns:
        result = re.sub(pattern, '', result, flags=re.IGNORECASE | re.MULTILINE | re.DOTALL)
    return result.strip()


def clean_response(raw_output: str) -> str:
    """Extract commit message from AI response and remove signatures."""
    match = re.search(CONVENTIONAL_REGEX, raw_output, re.MULTILINE)
    if match:
        message = raw_output[match.start():].strip()
    else:
        message = raw_output.strip()
    return strip_signatures(message)


def call_local_fallback(diff: str) -> str:
    """Fallback to local heuristic engine."""
    local_bridge = os.path.join(os.path.dirname(__file__), "local_bridge.py")
    if os.path.exists(local_bridge):
        import subprocess
        proc = subprocess.Popen(
            [sys.executable, local_bridge],
            stdin=subprocess.PIPE, stdout=subprocess.PIPE,
            text=True, encoding='utf-8'
        )
        stdout, _ = proc.communicate(input=diff)
        return stdout.strip()
    return "chore: update files"


@app.command()
def commit(
    provider: str = typer.Option(None, "-p", "--provider", help="AI provider to use."),
    dry_run: bool = typer.Option(False, "-d", "--dry-run", help="Preview without committing.")
):
    """Generate a commit message using AI."""
    if not shutil.which("git"):
        typer.secho("Git not found!", fg=typer.colors.RED)
        sys.exit(1)

    # Select provider
    provider_name = provider or config_mgr.get_default_provider()
    provider_cfg = config_mgr.get_provider_config(provider_name)

    if not provider_cfg:
        typer.secho(f"Provider '{provider_name}' not found.", fg=typer.colors.RED)
        typer.echo("Use 'sensei ls' to see available providers.")
        sys.exit(1)

    typer.echo(f"Using: {provider_name}")

    # Get diff
    diff = get_staged_diff()
    if not diff:
        typer.secho("No staged changes.", fg=typer.colors.YELLOW)
        sys.exit(0)

    # Secrets check
    secrets = scan_diff(diff)
    if secrets:
        typer.secho(format_warning(secrets), fg=typer.colors.YELLOW)
        if not typer.confirm("Continue anyway?", default=False):
            sys.exit(1)

    # Gather git context
    git_context = get_git_context()

    # Show context info
    if git_context.get('context_summary'):
        typer.secho(f"Context: {git_context['context_summary']}", fg=typer.colors.CYAN)

    # Generate message
    typer.echo("Thinking...")
    # Priority: provider-specific prompt > universal prompt > default
    base_prompt = provider_cfg.get("prompt") or config_mgr.get_universal_prompt() or DEFAULT_PROMPT
    prompt = build_prompt_with_context(base_prompt, git_context)
    ai = AIProvider(provider_name, provider_cfg)
    raw = ai.execute(diff, prompt)

    message = clean_response(raw) if raw else call_local_fallback(diff)

    # Review loop
    while True:
        typer.echo("-" * 50)
        typer.secho(message, fg=typer.colors.GREEN)
        typer.echo("-" * 50)

        if dry_run:
            break

        choice = typer.prompt("[y]es, [n]o, [e]dit, [r]etry", default="y").lower()

        if choice in ('y', 'yes'):
            if create_commit(message):
                typer.secho("Committed!", fg=typer.colors.GREEN)
            break
        elif choice in ('e', 'edit'):
            message = typer.prompt("Message", default=message).strip()
        elif choice in ('r', 'retry'):
            raw = ai.execute(diff, prompt)
            if raw:
                message = clean_response(raw)
        elif choice in ('n', 'no'):
            typer.secho("Aborted.", fg=typer.colors.RED)
            break


@app.command(name="ls")
def list_providers():
    """List available AI providers."""
    default = config_mgr.get_default_provider()
    for name, desc in config_mgr.list_providers().items():
        prefix = "*" if name == default else " "
        typer.echo(f"{prefix} {name}: {desc}")


@app.command()
def use(provider: str = typer.Argument(..., help="Provider name.")):
    """Set the default AI provider."""
    if provider not in config_mgr.list_providers():
        typer.secho(f"Provider '{provider}' not found.", fg=typer.colors.RED)
        sys.exit(1)

    if config_mgr.set_default_provider(provider):
        typer.secho(f"Default set to '{provider}'.", fg=typer.colors.GREEN)
    else:
        typer.secho("Failed to save.", fg=typer.colors.RED)
        sys.exit(1)


@app.command()
def check(provider: str = typer.Argument(None, help="Provider to check.")):
    """Check if an AI provider is working."""
    target = provider or config_mgr.get_default_provider()
    cfg = config_mgr.get_provider_config(target)

    if not cfg:
        typer.secho(f"Provider '{target}' not found.", fg=typer.colors.RED)
        sys.exit(1)

    typer.echo(f"Checking: {target}")
    ai = AIProvider(target, cfg)

    if ai.check_health():
        typer.secho("OK - executable found.", fg=typer.colors.GREEN)
    else:
        typer.secho("NOT FOUND - check PATH.", fg=typer.colors.RED)


@app.command()
def init():
    """Interactive setup wizard."""
    typer.echo("Welcome to Git-Sensei!\n")

    # Check for existing config
    config_path = os.path.expanduser("~/.sensei.toml")
    if os.path.exists(config_path):
        typer.secho("Existing configuration found.", fg=typer.colors.YELLOW)
        if not typer.confirm("Overwrite?", default=False):
            typer.echo("Keeping existing config.")
            return

    providers = {
        "1": ("gemini", "Google Gemini", "npm i -g @google/gemini-cli"),
        "2": ("claude", "Claude Code", "npm i -g @anthropic-ai/claude-code"),
        "3": ("openai", "OpenAI GPT-4", "pip install chatgpt-cli"),
        "4": ("ollama", "Ollama (local)", "https://ollama.ai"),
    }

    typer.echo("Select your AI provider:\n")
    for key, (_, name, install) in providers.items():
        typer.echo(f"  {key}. {name} ({install})")

    choice = typer.prompt("\nSelect provider", default="1")
    if choice not in providers:
        typer.secho("Invalid choice.", fg=typer.colors.RED)
        sys.exit(1)

    selected, name, install_cmd = providers[choice]
    typer.echo(f"\nSelected: {name}")

    # Get provider config for connection test
    provider_cfg = config_mgr.get_provider_config(selected)
    if not provider_cfg:
        typer.secho(f"Provider '{selected}' not configured.", fg=typer.colors.RED)
        sys.exit(1)

    # Test connection
    typer.echo("Testing connection... ", nl=False)
    ai = AIProvider(selected, provider_cfg)
    success, msg = ai.test_connection()

    if success:
        typer.secho("OK", fg=typer.colors.GREEN)
    else:
        typer.secho("FAILED", fg=typer.colors.RED)
        typer.echo(f"  {msg}")
        typer.echo(f"\nInstall: {install_cmd}")
        if not typer.confirm("\nContinue anyway?", default=False):
            sys.exit(1)

    # Save config
    if config_mgr.set_default_provider(selected):
        typer.secho(f"\nConfig saved to {config_path}", fg=typer.colors.GREEN)
        typer.echo(f"Default provider: {selected}")
        typer.echo("\nReady! Run: git add . && sensei commit")
    else:
        typer.secho("Setup failed.", fg=typer.colors.RED)
        sys.exit(1)


if __name__ == "__main__":
    app(prog_name="sensei")
